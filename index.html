<!DOCTYPE html>
<html>
  <head>
    <title>AR/VR Learning</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  </head>
  <body>
    <a-scene renderer="alpha: true">
      <a-assets>
        <img   id="display-img" src="ARVR_Learning_Background.png">
        <img   id="rainbow-img" src="rainbow.png">
        <audio id="bg-audio"    src="sentences%20unfinished.m4a" preload="auto" loop></audio>
      </a-assets>

      <!-- â”€â”€ Day environment (camera faces -Z) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <a-box      id="box"      position="-1 0.5 -3"  rotation="0 45 0"  color="#304ffe"></a-box>
      <a-sphere   id="sphere"   position="0 1.25 -5"  radius="1.25"      color="#ff1d89"></a-sphere>
      <a-cylinder id="cylinder" position="1 0.75 -3"  radius="0.5" height="1.5" color="#ffec00"></a-cylinder>
      <a-plane    id="plane"    position="0 0 -4"     rotation="-90 0 0" width="4" height="4" color="#bcf804"></a-plane>
      <a-plane    id="image-plane"         src="#display-img" position="0 1.25 -6"   width="5" height="5"></a-plane>
      <a-plane    id="image-plane-trigger" src="#rainbow-img"  position="0 1.25 -5.9" width="5" height="5"
                  material="transparent: true; opacity: 0"></a-plane>

      <!-- â”€â”€ Night environment (camera faces +Z after 180Â° rig rotation) â”€â”€â”€ -->
      <a-box      id="night-box"      position="1 0.5 3"   rotation="0 -45 0" color="#304ffe" visible="false"></a-box>
      <a-sphere   id="night-sphere"   position="0 1.25 5"  radius="1.25"      color="#ff1d89" visible="false"></a-sphere>
      <a-cylinder id="night-cylinder" position="-1 0.75 3" radius="0.5" height="1.5" color="#ffec00" visible="false"></a-cylinder>
      <a-plane    id="night-plane"    position="0 0 4"     rotation="-90 0 0" width="4" height="4" color="#bcf804" visible="false"
                  animation__move="property: position; from: -8 0 4; to: 8 0 4; dir: alternate; dur: 4000; loop: true; autoplay: false; easing: easeOutQuart"></a-plane>
      <!-- Bounce sphere: drops from above with easeOutBounce each cycle in night mode -->
      <a-sphere   id="night-bounce-sphere" position="2.5 6 3" radius="0.4" color="#F58A07" visible="false"
                  animation__bounce="property: position; from: 2.5 6 3; to: 2.5 1.5 3; dur: 1800; easing: easeOutElastic; loop: true; autoplay: false"></a-sphere>

      <!-- Orbit rig: invisible parent entity positioned at nightSphere's center.
           Y-rotation carries the child sphere in a continuous circle.
           The child's X offset is the orbit radius (2 units from center). -->
      <a-entity id="orbit-rig" position="0 1.25 5" visible="false"
                animation__orbit="property: rotation; from: 0 0 0; to: 0 0 360; loop: true; dur: 4000; easing: linear">
        <a-sphere id="orbit-sphere" position="0 2 0" radius="0.42" color="#44FFD1"></a-sphere>
      </a-entity>

      <!-- rotation="0 180 0" flips the plane normal to face -Z, toward the night camera -->
      <a-plane    id="night-image-plane"         src="#display-img" position="0 1.25 6"   rotation="0 180 0" width="5" height="5" visible="false"></a-plane>
      <a-plane    id="night-image-plane-trigger" src="#rainbow-img"  position="0 1.25 5.9" rotation="0 180 0" width="5" height="5"
                  material="transparent: true; opacity: 0" visible="false"></a-plane>

      <a-sky id="sky" color="#ECECEC"></a-sky>

      <!-- Camera rig: holds world position and Y-rotation for environment switching.
           The inner camera handles look-controls and zoom movement independently. -->
      <a-entity id="camera-rig" position="0 1.6 0">
        <a-camera id="camera" camera="userHeight: 0"></a-camera>
      </a-entity>
    </a-scene>

    <!-- Night mode toggle: circle button, upper-right viewport overlay -->
    <a id="myEnterARButton" href="#" title="Toggle Night Mode">ðŸ’¡</a>

    <!-- Mute button: below night mode button, upper-right viewport overlay -->
    <a id="muteBtn" href="#" title="Mute / Unmute">ðŸ”Š</a>

    <!-- Rainbow easter egg button: night-mode only, below mute button -->
    <a id="rainbowBtn" href="#" title="âœ¨ Easter Egg">ðŸŒˆ</a>

    <!-- AR camera button: always visible, activates live camera feed -->
    <a id="arBtn" href="#" title="Toggle AR Camera">ðŸ“·</a>

    <!-- Live camera feed rendered behind the A-Frame canvas in AR mode -->
    <video id="ar-video" autoplay playsinline muted></video>

    <!-- AR error toast: shown briefly when camera fails to initialize -->
    <div id="ar-error"></div>

    <script>
      const btn        = document.querySelector('#myEnterARButton');
      const muteBtn    = document.querySelector('#muteBtn');
      const rainbowBtn = document.querySelector('#rainbowBtn');
      const arBtn      = document.querySelector('#arBtn');
      const arVideo    = document.querySelector('#ar-video');
      const cameraRig  = document.querySelector('#camera-rig');
      const sky        = document.querySelector('#sky');

      // Day environment elements (visibility-toggled only â€” no animations)
      const dayEls = [
        document.querySelector('#box'),
        document.querySelector('#sphere'),
        document.querySelector('#cylinder'),
        document.querySelector('#plane'),
        document.querySelector('#image-plane'),
        document.querySelector('#image-plane-trigger'),
      ];

      // Night environment elements
      const nightBounceSphere      = document.querySelector('#night-bounce-sphere');
      const nightBox               = document.querySelector('#night-box');
      const nightSphere            = document.querySelector('#night-sphere');
      const nightCylinder          = document.querySelector('#night-cylinder');
      const nightPlane             = document.querySelector('#night-plane');
      const nightImagePlane        = document.querySelector('#night-image-plane');
      const nightImagePlaneTrigger = document.querySelector('#night-image-plane-trigger');
      const orbitRig               = document.querySelector('#orbit-rig');
      const orbitSphere            = document.querySelector('#orbit-sphere');

      // Night primitives that receive emissive glow + visibility toggling.
      // scalesIn: true  â†’ entrance/exit handled by setNightObjectScale()
      // scalesIn: false â†’ visibility toggled directly
      const nightPrimitives = [
        { el: nightBox,          glowColor: '#304ffe', scalesIn: true  },
        { el: nightSphere,       glowColor: '#ff1d89', scalesIn: true  },
        { el: nightCylinder,     glowColor: '#ffec00', scalesIn: false },
        { el: nightPlane,        glowColor: '#bcf804', scalesIn: false },
        { el: nightBounceSphere, glowColor: '#F58A07', scalesIn: false },
      ];

      const bgAudio = document.querySelector('#bg-audio');

      let isNightMode    = false;
      let isARMode       = false;
      let isMuted        = false;
      let isImageVisible = false;
      let triggerTimeout  = null;
      let triggerInterval = null;
      let arStream        = null;

      const EASTER_EGG_URL = 'rainbow.html';

      // Night environment resting positions / rotations
      const NIGHT_PLANE_ORIGIN  = '0 0 4';
      const NIGHT_SPHERE_ORIGIN = '0 1.25 5';
      const NIGHT_SPHERE_TARGET = '0 4 5';
      const NIGHT_BOX_ROTATION  = '0 -45 0';
      const CYLINDER_SCALE      = '1 1 1';

      // Bounce sphere drop: starts high (y=6), elastic landing target at y=1.5.
      // easeOutElastic overshoots ~40% of travel distance â€” landing at y=0.4 would
      // clip through the floor, so y=1.5 keeps the oscillation above ground.
      const BOUNCE_START = '2.5 6 3';
      const BOUNCE_LAND  = '2.5 1.5 3';

      // Scale an object in (show=true) or out (show=false).
      // Scale-in: makes the object visible, resets its scale to 0, then tweens to 1
      //   using easeOutBack â€” the slight overshoot gives a satisfying "pop" on arrival.
      // Scale-out: tweens scale to 0 using easeInCubic (accelerates into nothing),
      //   then hides the object only after the tween completes. The isNightMode guard
      //   prevents hiding if the user toggles back before the animation finishes.
      function setNightObjectScale(el, show) {
        el.removeAttribute('animation__scale');
        if (show) {
          el.setAttribute('visible', true);
          el.setAttribute('scale', '0 0 0');
          // Loop alternates 0â†’1â†’0â†’1 continuously so the effect is always
          // visible regardless of when the camera rig finishes rotating.
          el.setAttribute('animation__scale',
            'property: scale; from: 0 0 0; to: 1 1 1; dir: alternate; loop: true; dur: 1500; easing: easeInOutSine');
        } else {
          // No `from` â€” A-Frame reads the current scale at interrupt time,
          // so the shrink starts from wherever the loop left off.
          el.setAttribute('animation__scale',
            'property: scale; to: 0 0 0; dur: 400; easing: easeInCubic');
          function onScaleOut() {
            el.removeEventListener('animationcomplete__scale', onScaleOut);
            if (!isNightMode) {
              el.setAttribute('visible', false);
              el.setAttribute('scale', '1 1 1');
            }
          }
          el.addEventListener('animationcomplete__scale', onScaleOut);
        }
      }

      // Drop the bounce sphere from BOUNCE_START to BOUNCE_LAND with easeOutBounce.
      // The animation is declared inline in HTML (autoplay: false) so it is fully
      // initialized at load time â€” toggling autoplay follows the same pattern as the
      // night-plane and avoids dynamic component initialization race conditions.
      function setBounceAnimation(active) {
        if (active) {
          nightBounceSphere.setAttribute('position', BOUNCE_START);
          nightBounceSphere.setAttribute('animation__bounce', 'autoplay', true);
        } else {
          nightBounceSphere.setAttribute('animation__bounce', 'autoplay', false);
          nightBounceSphere.setAttribute('position', BOUNCE_START);
        }
      }

      // Fade the night trigger overlay in or out.
      function setImageTriggerFade(show) {
        isImageVisible = show;
        nightImagePlaneTrigger.removeAttribute('animation__fade');
        nightImagePlaneTrigger.setAttribute('animation__fade',
          'property: material.opacity; from: ' + (show ? 0 : 1) + '; to: ' + (show ? 1 : 0) +
          '; dur: 800; easing: ' + (show ? 'easeInSine' : 'easeOutSine'));
      }

      function startImageTrigger() {
        triggerTimeout = setTimeout(function () {
          setImageTriggerFade(true);
          triggerInterval = setInterval(function () {
            setImageTriggerFade(!isImageVisible);
          }, 3000);
        }, 3000);
      }

      function stopImageTrigger() {
        clearTimeout(triggerTimeout);
        clearInterval(triggerInterval);
        triggerTimeout  = null;
        triggerInterval = null;
        nightImagePlaneTrigger.removeAttribute('animation__fade');
        nightImagePlaneTrigger.setAttribute('material', 'opacity', 0);
        isImageVisible = false;
      }

      function setAudio(playing) {
        if (playing) {
          bgAudio.play().catch(function () {});
        } else {
          bgAudio.pause();
        }
      }

      function setMute(muted) {
        bgAudio.volume = muted ? 0 : 1;
        muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
      }

      function setPlaneAnimation(playing) {
        nightPlane.setAttribute('animation__move', 'autoplay', playing);
      }

      function resetPlanePosition() {
        nightPlane.setAttribute('position', NIGHT_PLANE_ORIGIN);
      }

      // Scale both night planes between 1Ã—1Ã—1 and 2Ã—2Ã—2 on a continuous loop.
      // Uses a separate animation slot (animation__scalepulse) so it doesn't
      // conflict with the position slide already running on nightPlane.
      function setNightPlaneScalePulse(active) {
        [nightPlane, nightImagePlane].forEach(function (el) {
          if (active) {
            el.setAttribute('animation__scalepulse',
              'property: scale; from: 1 1 1; to: 2 2 2; dir: alternate; loop: true; dur: 2000; easing: easeInOutSine');
          } else {
            el.removeAttribute('animation__scalepulse');
            el.setAttribute('scale', '1 1 1');
          }
        });
      }

      function setCylinderPulse(pulsing) {
        if (pulsing) {
          nightCylinder.setAttribute('animation__pulse',
            'property: scale; from: 1 1 1; to: 1.5 0.6 1.5; dir: alternate; loop: true; dur: 600; easing: easeInOutSine');
        } else {
          nightCylinder.removeAttribute('animation__pulse');
          nightCylinder.setAttribute('scale', CYLINDER_SCALE);
        }
      }

      function setBoxSpin(spinning) {
        if (spinning) {
          nightBox.setAttribute('animation__spin',
            'property: rotation; from: 0 -45 0; to: 0 315 0; loop: true; dur: 4000; easing: linear');
        } else {
          nightBox.removeAttribute('animation__spin');
          nightBox.setAttribute('rotation', NIGHT_BOX_ROTATION);
        }
      }

      function setSpherePosition(rising) {
        if (rising) {
          nightSphere.removeAttribute('animation__fall');
          nightSphere.setAttribute('animation__rise',
            'property: position; to: ' + NIGHT_SPHERE_TARGET + '; dur: 2000; easing: easeInOutQuad');
        } else {
          nightSphere.removeAttribute('animation__rise');
          nightSphere.setAttribute('animation__fall',
            'property: position; to: ' + NIGHT_SPHERE_ORIGIN + '; dur: 2000; easing: easeInOutQuad');
        }
      }

      // Single source of truth for sky visibility.
      // AR mode hides the sky entirely so the camera feed shows through the
      // transparent canvas. Day/night only changes the sky color; it stays
      // hidden in AR regardless of which mode is active.
      function updateSky() {
        if (isARMode) {
          sky.setAttribute('visible', false);
        } else {
          sky.setAttribute('visible', true);
          sky.setAttribute('color', isNightMode ? '#000000' : '#ECECEC');
        }
      }

      // Show a brief error toast for AR failures.
      const arError = document.querySelector('#ar-error');
      function showARError(msg) {
        arError.textContent = msg;
        arError.style.display = 'block';
        clearTimeout(showARError._t);
        showARError._t = setTimeout(function () { arError.style.display = 'none'; }, 6000);
      }

      // Request the rear camera, pipe it into the background video element,
      // and hide the sky so the transparent canvas reveals the feed.
      // On deactivation, kill the stream tracks and restore the sky.
      async function setARMode(active) {
        if (active) {
          // getUserMedia is only available in a secure context (HTTPS or localhost).
          if (!window.isSecureContext) {
            showARError('Camera requires HTTPS. Serve this page over a secure connection.');
            console.error('[AR] Page is not in a secure context â€” getUserMedia unavailable.');
            return;
          }
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            showARError('Camera API not supported in this browser.');
            console.error('[AR] navigator.mediaDevices.getUserMedia is not available.');
            return;
          }
          try {
            // First attempt: request rear-facing camera explicitly.
            arStream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: 'environment' }
            });
          } catch (err) {
            // On iOS Chrome, facingMode: 'environment' can fail even when a camera
            // is available. Fall back to any camera before giving up.
            console.warn('[AR] facingMode:environment failed, trying plain video:', err);
            try {
              arStream = await navigator.mediaDevices.getUserMedia({ video: true });
            } catch (err2) {
              console.error('[AR] Camera access failed:', err2);
              showARError('Camera access denied. Check browser permissions and try again.');
              isARMode = false;
              return;
            }
          }
          arVideo.srcObject = arStream;
          isARMode = true;
          arBtn.textContent = 'ðŸ”´';
          document.body.classList.add('ar-mode');
        } else {
          if (arStream) {
            arStream.getTracks().forEach(function (t) { t.stop(); });
            arStream = null;
          }
          arVideo.srcObject = null;
          isARMode = false;
          arBtn.textContent = 'ðŸ“·';
          document.body.classList.remove('ar-mode');
        }
        updateSky();
      }

      // â”€â”€ Night mode toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      btn.addEventListener('click', function (e) {
        e.preventDefault();
        isNightMode = !isNightMode;

        updateSky();
        document.body.classList.toggle('night-mode', isNightMode);

        // Rotate the camera rig 180Â° to face the night environment, or back.
        // Using explicit from/to keeps the direction consistent on every toggle.
        cameraRig.removeAttribute('animation__turn');
        cameraRig.setAttribute('animation__turn',
          'property: rotation; ' +
          'from: 0 ' + (isNightMode ? 0 : 180) + ' 0; ' +
          'to: 0 '   + (isNightMode ? 180 : 0) + ' 0; ' +
          'dur: 1500; easing: easeInOutCubic');

        if (isNightMode) {
          // Hide day environment, reveal night environment
          dayEls.forEach(function (el) { el.setAttribute('visible', false); });
          nightPrimitives.forEach(function (p) {
            if (p.scalesIn) {
              setNightObjectScale(p.el, true);
            } else {
              p.el.setAttribute('visible', true);
            }
            p.el.setAttribute('material', 'emissive', p.glowColor);
            p.el.setAttribute('material', 'emissiveIntensity', 0.75);
          });
          nightImagePlane.setAttribute('visible', true);
          nightImagePlaneTrigger.setAttribute('visible', true);
          orbitRig.setAttribute('visible', true);
          orbitSphere.setAttribute('material', 'emissive', '#44FFD1');
          orbitSphere.setAttribute('material', 'emissiveIntensity', 0.75);

          setBounceAnimation(true);
          setPlaneAnimation(true);
          setNightPlaneScalePulse(true);
          setSpherePosition(true);
          setBoxSpin(true);
          setCylinderPulse(true);
          setAudio(true);
          startImageTrigger();
        } else {
          // Reveal day environment, hide night environment
          dayEls.forEach(function (el) { el.setAttribute('visible', true); });
          nightPrimitives.forEach(function (p) {
            if (p.scalesIn) {
              setNightObjectScale(p.el, false);
            } else {
              p.el.setAttribute('visible', false);
            }
            p.el.setAttribute('material', 'emissiveIntensity', 0);
          });
          nightImagePlane.setAttribute('visible', false);
          nightImagePlaneTrigger.setAttribute('visible', false);
          orbitRig.setAttribute('visible', false);
          orbitSphere.setAttribute('material', 'emissiveIntensity', 0);

          setBounceAnimation(false);
          setPlaneAnimation(false);
          setNightPlaneScalePulse(false);
          resetPlanePosition();
          setSpherePosition(false);
          setBoxSpin(false);
          setCylinderPulse(false);
          setAudio(false);
          bgAudio.currentTime = 0;
          stopImageTrigger();

          // Reset rig position in case the zoom was used
          cameraRig.removeAttribute('animation__zoom');
          cameraRig.setAttribute('position', '0 1.6 0');
        }
      });

      // â”€â”€ Mute button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      muteBtn.addEventListener('click', function (e) {
        e.preventDefault();
        isMuted = !isMuted;
        setMute(isMuted);
      });

      // â”€â”€ AR camera button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      arBtn.addEventListener('click', function (e) {
        e.preventDefault();
        setARMode(!isARMode);
      });

      // â”€â”€ Rainbow easter egg button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Zooms the camera rig toward the night image plane (+Z), then opens the URL.
      rainbowBtn.addEventListener('click', function (e) {
        e.preventDefault();
        cameraRig.removeAttribute('animation__zoom');

        function onZoomComplete() {
          cameraRig.removeEventListener('animationcomplete__zoom', onZoomComplete);
          window.open(EASTER_EGG_URL, '_blank');
        }
        cameraRig.addEventListener('animationcomplete__zoom', onZoomComplete);

        cameraRig.setAttribute('animation__zoom',
          'property: position; to: 0 1.25 6; dur: 2500; easing: easeInOutCubic');
      });
    </script>
  </body>
</html>
